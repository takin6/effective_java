ITEM 10: OBEY THE GENERAL CONTRACT WHEN OVERRIDING EQUALS

The easiest way to avoid problems is not to override the equals method, in which case each instance of the class is equal only to itself.
This is the right thing to do if any of the following conditions apply:
- Each instance of the class is inherently unique
- There is no need for the class to provide a “logical equality” test.
- A superclass has already overridden equals, and the superclass behavior is appropriate for this class.
- The class is private or package-private, and you are certain that its equals method will never be invoked.


So when is it appropriate to override equals?
- when a class has a notion of logical equality that differs from mere object identity
- a superclass has not already overridden equals

- The equals method implements an equivalence relation. It has these properties:
  • Reflexive: For any non-null reference value x, x.equals(x) must return true.
  • Symmetric: For any non-null reference values x and y, x.equals(y) must return true if and only if y.equals(x) returns true.
  • Transitive: For any non-null reference values x, y, z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) must return true.
  • Consistent: For any non-null reference values x and y, multiple invocations of x.equals(y) must consistently return true or consistently return false, provided no information used in equals comparisons is modified.
                do not write an equals method that depends on unreliable resources.ex)url
  • For any non-null reference value x, x.equals(null) must return false.

- It turns out that this is a fundamental problem of equivalence relations in object-oriented languages.
  There is no way to extend an instantiable class and add a value component while preserving the equals contract


- While there is no satisfactory way to extend an instantiable class and add a value component, there is a fine workaround: Follow the advice of Item 18, “Favor composition over inheritance.”
  Instead of having ColorPoint extend Point, give ColorPoint a private Point field and a public view method (Item 6) that returns the point at the same position as this color point

- Note that you can add a value component to a subclass of an abstract class without violating the equals contract.


Putting it all together, here’s a recipe for a high-quality equals method:
1. Use the == operator to check if the argument is a reference to this object.
2. Use the instanceof operator to check if the argument has the correct type.
3. Cast the argument to the correct type.
4. For each “significant” field in the class, check if that field of the argument matches the corresponding field of this object.
    For primitive fields whose type is not float or double, use the == operator for
    comparisons; for object reference fields, call the equals method recursively;
    for float fields, use the static Float.compare(float, float) method; and
    for double fields, use Double.compare(double, double). The special treatment of float and double fields is made necessary by the existence of
    Float.NaN, -0.0f and the analogous double values; see JLS 15.21.1 or the
    documentation of Float.equals for details.

When you are finished writing your equals method, ask yourself three questions: Is it symmetric? Is it transitive? Is it consistent?

• Always override hashCode when you override equals (Item 11).
• Don’t substitute another type for Object in the equals declaration.

Writing and testing equals (and hashCode) methods is tedious, and the resulting code is mundane.
An excellent alternative to writing and testing these methods manually is to use Google’s open source AutoValue framework, which automatically generates these methods for you, triggered by a single annotation on the class .
In most cases, the methods generated by AutoValue are essentially identical to those you’d write yourself.


SUMMARY
In summary, don’t override the equals method unless you have to:
in many cases, the implementation inherited from Object does exactly what you want.
If you do override equals, make sure to compare all of the class’s significant fields and to compare them in a manner that preserves all five provisions of the equals contract.
